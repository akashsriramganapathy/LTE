package com.github.libretube.test.util

import android.util.Log
import com.github.libretube.test.api.MediaServiceRepository
import com.github.libretube.test.api.obj.DeArrowContent
import com.github.libretube.test.api.obj.Streams
import com.github.libretube.test.constants.PreferenceKeys
import com.github.libretube.test.helpers.PreferenceHelper
import com.github.libretube.test.api.obj.StreamItem
import com.github.libretube.test.extensions.toID
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.withContext
import com.github.libretube.test.api.JsonHelper
import com.github.libretube.test.db.DatabaseHolder
import com.github.libretube.test.db.obj.DeArrowCacheItem
import kotlinx.serialization.encodeToString

object DeArrowUtil {
    private const val CACHE_EXPIRY_MS = 24 * 60 * 60 * 1000L
    fun extractTitleAndThumbnail(content: DeArrowContent, videoId: String, duration: Float? = null): Pair<String?, String?> {
        // Sort titles by: Locked (priority), Votes (desc), and prefer Non-Original
        val title = content.titles.asSequence()
            .filter { it.votes >= 0 || it.locked }
            .sortedWith(
                compareByDescending<com.github.libretube.test.api.obj.DeArrowTitle> { it.locked }
                    .thenByDescending { it.votes }
                    .thenBy { it.original } // false (non-original) < true. So ascending puts non-original first.
            )
            .firstOrNull()?.title
        
        var thumbnail: String? = null

        // 1. Try randomTime first (User requested "always simple random timestamp")
        if (content.randomTime != null) {
            val videoDuration = duration ?: content.videoDuration
            if (videoDuration != null) {
                val timestamp = content.randomTime * videoDuration
                thumbnail = "https://dearrow-thumb.ajay.app/api/v1/getThumbnail?videoID=$videoId&time=$timestamp"
            }
        }
        
        // 2. Fallback to curated thumbnails if randomTime is missing (unlikely, but safe)
        if (thumbnail == null) {
            val bestThumb = content.thumbnails.firstOrNull { it.locked } ?: content.thumbnails.maxByOrNull { it.votes }
            if (bestThumb != null && !bestThumb.original && bestThumb.timestamp != null) {
                 thumbnail = "https://dearrow-thumb.ajay.app/api/v1/getThumbnail?videoID=$videoId&time=${bestThumb.timestamp}"
            }
        }

        return title to thumbnail
    }


    private suspend fun fetchDeArrowContent(videoId: String): DeArrowContent? {
        // 1. Check Cache
        val cacheDao = DatabaseHolder.Database.deArrowCacheDao()
        val cachedItem = cacheDao.get(videoId)
        
        if (cachedItem != null) {
            val isExpired = System.currentTimeMillis() - cachedItem.timestamp > CACHE_EXPIRY_MS
            if (!isExpired) {
                try {
                    val content = JsonHelper.json.decodeFromString<DeArrowContent>(cachedItem.contentJson)
                    android.util.Log.d("DeArrowUtil", "CACHE HIT: $videoId")
                    return content
                } catch (e: Exception) {
                    android.util.Log.e("DeArrowUtil", "Cache parse error for $videoId", e)
                }
            } else {
                android.util.Log.d("DeArrowUtil", "CACHE EXPIRED: $videoId")
            }
        }

        // 2. Fetch from Network
        android.util.Log.d("DeArrowUtil", "fetchDeArrowContent: Fetching for $videoId")
        val content = MediaServiceRepository.instance.getDeArrowContent(videoId)
        
        // 3. Save to Cache if successful
        if (content != null) {
            try {
                val json = JsonHelper.json.encodeToString(content)
                cacheDao.insert(DeArrowCacheItem(videoId, json))
                android.util.Log.d("DeArrowUtil", "CACHE SAVE: $videoId")
            } catch (e: Exception) {
                android.util.Log.e("DeArrowUtil", "Cache save error for $videoId", e)
            }
        }
        
        return content
    }

    /**
     * Apply the new titles and thumbnails generated by DeArrow to the streams item
     */
    suspend fun deArrowStreams(streams: Streams, vidId: String): Streams {
        val isDeArrowEnabled = PreferenceHelper.getBoolean(PreferenceKeys.DEARROW, true)
        val isThumbsEnabled = PreferenceHelper.getBoolean(PreferenceKeys.DEARROW_THUMBNAILS, true)

        if (!isDeArrowEnabled || !isThumbsEnabled) {
            streams.thumbnailUrl = revertThumbnail(streams.thumbnailUrl) ?: streams.thumbnailUrl
            if (!isDeArrowEnabled) return streams
        }

        if (streams.isLive && PreferenceHelper.getBoolean(PreferenceKeys.DEARROW_EXEMPT_LIVE, true)) return streams

        val data = fetchDeArrowContent(vidId)
        var thumbnailApplied = false

        data?.let { dataVal ->
            val (newTitle, newThumbnail) = extractTitleAndThumbnail(dataVal, vidId, streams.duration.toFloat())
            if (newTitle != null && PreferenceHelper.getBoolean(PreferenceKeys.DEARROW_TITLES, true)) {
                streams.title = newTitle
                Log.d("DeArrowUtil", "SUCCESS: Applied title for $vidId")
            }
            if (newThumbnail != null && isThumbsEnabled) {
                streams.thumbnailUrl = newThumbnail
                thumbnailApplied = true
                Log.d("DeArrowUtil", "SUCCESS: Applied thumb for $vidId. URL: $newThumbnail")
            }
        } ?: Log.d("DeArrowUtil", "NO CURATION: No DeArrow data for $vidId")
        
        if (!thumbnailApplied && isThumbsEnabled) {
             // Fallback to mq2.jpg (320x180, 16:9)
             val fallbackThumb = "https://i.ytimg.com/vi/$vidId/mq2.jpg"
             streams.thumbnailUrl = fallbackThumb
        }

        // De-arrow related streams if they exist
        if (streams.relatedStreams.isNotEmpty()) {
            streams.relatedStreams = deArrowStreamItems(streams.relatedStreams)
        }

        return streams
    }

    suspend fun deArrowStreamItems(items: List<StreamItem>): List<StreamItem> {
        val isDeArrowEnabled = PreferenceHelper.getBoolean(PreferenceKeys.DEARROW, true)
        val isThumbsEnabled = PreferenceHelper.getBoolean(PreferenceKeys.DEARROW_THUMBNAILS, true)

        if (!isDeArrowEnabled || !isThumbsEnabled) {
            items.forEach { item ->
                item.thumbnail = revertThumbnail(item.thumbnail)
            }
            if (!isDeArrowEnabled) return items
        }

        android.util.Log.d("DeArrowFeed", "deArrowStreamItems: count=${items.size}, enabled=$isDeArrowEnabled, thumbs=$isThumbsEnabled")

        if (items.isEmpty()) return items

        // Filter out items that are not streams or missing video ID
        val isExemptLive = PreferenceHelper.getBoolean(PreferenceKeys.DEARROW_EXEMPT_LIVE, true)
        val streamsToProcess = items.filter { it.url != null && (!it.isLive || !isExemptLive) }
        if (streamsToProcess.isEmpty()) return items

        val isTitlesEnabled = PreferenceHelper.getBoolean(PreferenceKeys.DEARROW_TITLES, true)

        coroutineScope {
            streamsToProcess.map { item ->
                async {
                    val videoId = item.url!!.toID()
                    var thumbnailApplied = false
                    
                    val data = fetchDeArrowContent(videoId)
                    data?.let { dataVal ->
                        val (newTitle, newThumbnail) = extractTitleAndThumbnail(dataVal, videoId, item.duration?.toFloat())
                        
                        if (newTitle != null && item.title != null && isTitlesEnabled) {
                            item.title = newTitle
                        }
                        if (newThumbnail != null && isThumbsEnabled) {
                            item.thumbnail = newThumbnail
                            Log.d("DeArrowFeed", "SUCCESS: Applied DeArrow thumb for $videoId. URL: $newThumbnail")
                            thumbnailApplied = true
                        }
                    }
                    
                    if (!thumbnailApplied && isThumbsEnabled) {
                         // Fallback to mq2.jpg
                         val fallbackThumb = "https://i.ytimg.com/vi/$videoId/mq2.jpg"
                         item.thumbnail = fallbackThumb
                    }
                }
            }.awaitAll()
        }
        
        return items
    }

    suspend fun deArrowContentItems(items: List<com.github.libretube.test.api.obj.ContentItem>): List<com.github.libretube.test.api.obj.ContentItem> {
        val isDeArrowEnabled = PreferenceHelper.getBoolean(PreferenceKeys.DEARROW, true)
        val isThumbsEnabled = PreferenceHelper.getBoolean(PreferenceKeys.DEARROW_THUMBNAILS, true)

        if (!isDeArrowEnabled || !isThumbsEnabled) {
            items.forEach { item ->
                item.thumbnail = revertThumbnail(item.thumbnail) ?: item.thumbnail
            }
            if (!isDeArrowEnabled) return items
        }

        android.util.Log.d("DeArrowFeed", "deArrowContentItems: count=${items.size}, enabled=$isDeArrowEnabled, thumbs=$isThumbsEnabled")

        if (items.isEmpty()) return items

        // Filter out items that are not streams or missing video ID
        val isExemptLive = PreferenceHelper.getBoolean(PreferenceKeys.DEARROW_EXEMPT_LIVE, true)
        val streamsToProcess = items.filter { it.type == com.github.libretube.test.api.obj.StreamItem.TYPE_STREAM && (it.duration > 0 || !isExemptLive) }
        if (streamsToProcess.isEmpty()) return items

        val isTitlesEnabled = PreferenceHelper.getBoolean(PreferenceKeys.DEARROW_TITLES, true)

        coroutineScope {
            streamsToProcess.map { item ->
                async {
                    val videoId = item.url.toID()
                    var thumbnailApplied = false
                    
                    val data = fetchDeArrowContent(videoId)
                    data?.let { dataVal ->
                        val (newTitle, newThumbnail) = extractTitleAndThumbnail(dataVal, videoId, item.duration.toFloat())
                        
                        if (newTitle != null && item.title != null && isTitlesEnabled) {
                            item.title = newTitle
                        }
                        if (newThumbnail != null && isThumbsEnabled) {
                            item.thumbnail = newThumbnail
                            Log.d("DeArrowFeed", "SUCCESS: Applied random thumb for $videoId. URL: $newThumbnail")
                            thumbnailApplied = true
                        } else {
                            Log.d("DeArrowFeed", "FAILURE: Could not gen thumb for $videoId. RandomTime=${dataVal.randomTime}, ItemDur=${item.duration}, ApiDur=${dataVal.videoDuration}")
                        }
                    }
                    
                    if (!thumbnailApplied && isThumbsEnabled) {
                         // Fallback to mq2.jpg
                         val fallbackThumb = "https://i.ytimg.com/vi/$videoId/mq2.jpg"
                         item.thumbnail = fallbackThumb
                    }
                }
            }.awaitAll()
        }
        
        return items
    }

    suspend fun deArrowWatchHistoryItems(items: List<com.github.libretube.test.db.obj.WatchHistoryItem>): List<com.github.libretube.test.db.obj.WatchHistoryItem> {
        val isDeArrowEnabled = PreferenceHelper.getBoolean(PreferenceKeys.DEARROW, true)
        val isThumbsEnabled = PreferenceHelper.getBoolean(PreferenceKeys.DEARROW_THUMBNAILS, true)

        if (!isDeArrowEnabled || !isThumbsEnabled) {
            items.forEach { item ->
                item.thumbnailUrl = revertThumbnail(item.thumbnailUrl)
            }
            if (!isDeArrowEnabled) return items
        }
        
        if (items.isEmpty()) return items

        // Filter out items that are not streams or missing video ID
        val isExemptLive = PreferenceHelper.getBoolean(PreferenceKeys.DEARROW_EXEMPT_LIVE, true)
        val streamsToProcess = items.filter { it.videoId.isNotEmpty() && (!it.isLive || !isExemptLive) }
        if (streamsToProcess.isEmpty()) return items

        val isTitlesEnabled = PreferenceHelper.getBoolean(PreferenceKeys.DEARROW_TITLES, true)

        coroutineScope {
            streamsToProcess.map { item ->
                async {
                    val videoId = item.videoId
                    var thumbnailApplied = false
                    
                    val data = fetchDeArrowContent(videoId)
                    data?.let { dataVal ->
                        val (newTitle, newThumbnail) = extractTitleAndThumbnail(dataVal, videoId, item.duration?.toFloat())
                        
                        if (newTitle != null && item.title != null && isTitlesEnabled) {
                            item.title = newTitle
                        }
                        if (newThumbnail != null && isThumbsEnabled) {
                            item.thumbnailUrl = newThumbnail
                            thumbnailApplied = true
                        }
                    }
                    
                    if (!thumbnailApplied && isThumbsEnabled) {
                         // Fallback to mq2.jpg
                         val fallbackThumb = "https://i.ytimg.com/vi/$videoId/mq2.jpg"
                         item.thumbnailUrl = fallbackThumb
                    }
                }
            }.awaitAll()
        }
        return items
    }

    fun getVideoIdFromThumbnailUrl(thumbnailUrl: String): String? {
        // Handle common YouTube thumbnail URL patterns
        // Matches /vi/ID, /vi_webp/ID, or videoID=ID
        val regex = Regex("(?:/vi/|/vi_webp/|videoID=|v=)([a-zA-Z0-9_-]{11})")
        return regex.find(thumbnailUrl)?.groupValues?.get(1)
    }

    private fun revertThumbnail(url: String?): String? {
        if (url?.contains("dearrow-thumb.ajay.app") == true) {
            val videoId = getVideoIdFromThumbnailUrl(url)
            if (videoId != null) {
                return "https://i.ytimg.com/vi/$videoId/mq2.jpg"
            }
        }
        return url
    }

    suspend fun deArrowPlaylists(items: List<com.github.libretube.test.api.obj.Playlists>): List<com.github.libretube.test.api.obj.Playlists> {
        val isDeArrowEnabled = PreferenceHelper.getBoolean(PreferenceKeys.DEARROW, true)
        val isThumbsEnabled = PreferenceHelper.getBoolean(PreferenceKeys.DEARROW_THUMBNAILS, true)

        if (!isDeArrowEnabled || !isThumbsEnabled) {
            items.forEach { item ->
                item.thumbnail = revertThumbnail(item.thumbnail)
            }
            return items
        }

        if (items.isEmpty()) return items

        val playlistsToProcess = items.filter { it.thumbnail != null }
        if (playlistsToProcess.isEmpty()) return items

        coroutineScope {
            playlistsToProcess.map { playlist ->
                async {
                    val videoId = getVideoIdFromThumbnailUrl(playlist.thumbnail!!)
                    if (videoId != null) {
                        var thumbnailApplied = false
                        val data = fetchDeArrowContent(videoId)
                        data?.let { dataVal ->
                            val (_, newThumbnail) = extractTitleAndThumbnail(dataVal, videoId)
                            if (newThumbnail != null) {
                                playlist.thumbnail = newThumbnail
                                thumbnailApplied = true
                            }
                        }
                        
                        if (!thumbnailApplied) {
                            // Fallback to mq2.jpg
                            playlist.thumbnail = "https://i.ytimg.com/vi/$videoId/mq2.jpg"
                        }
                    }
                }
            }.awaitAll()
        }
        return items
    }

    suspend fun deArrowPlaylistBookmarks(items: List<com.github.libretube.test.db.obj.PlaylistBookmark>): List<com.github.libretube.test.db.obj.PlaylistBookmark> {
        val isDeArrowEnabled = PreferenceHelper.getBoolean(PreferenceKeys.DEARROW, true)
        val isThumbsEnabled = PreferenceHelper.getBoolean(PreferenceKeys.DEARROW_THUMBNAILS, true)

        if (!isDeArrowEnabled || !isThumbsEnabled) {
            items.forEach { item ->
                item.thumbnailUrl = revertThumbnail(item.thumbnailUrl)
            }
            return items
        }

        if (items.isEmpty()) return items

        val bookmarksToProcess = items.filter { it.thumbnailUrl != null }
        if (bookmarksToProcess.isEmpty()) return items

        coroutineScope {
            bookmarksToProcess.map { bookmark ->
                async {
                    val videoId = getVideoIdFromThumbnailUrl(bookmark.thumbnailUrl!!)
                    if (videoId != null) {
                        var thumbnailApplied = false
                        val data = fetchDeArrowContent(videoId)
                        data?.let { dataVal ->
                            val (_, newThumbnail) = extractTitleAndThumbnail(dataVal, videoId)
                            if (newThumbnail != null) {
                                bookmark.thumbnailUrl = newThumbnail
                                thumbnailApplied = true
                            }
                        }
                        
                        if (!thumbnailApplied) {
                            // Fallback to mq2.jpg
                             bookmark.thumbnailUrl = "https://i.ytimg.com/vi/$videoId/mq2.jpg"
                        }
                    }
                }
            }.awaitAll()
        }
        return items
    }

    suspend fun deArrowVideoId(videoId: String): Pair<String?, String?>? {
        if (!PreferenceHelper.getBoolean(PreferenceKeys.DEARROW, true)) return null

        val data = fetchDeArrowContent(videoId) ?: return null
        val (title, thumb) = extractTitleAndThumbnail(data, videoId)
        val finalTitle = if (PreferenceHelper.getBoolean(PreferenceKeys.DEARROW_TITLES, true)) title else null
        val finalThumb = if (PreferenceHelper.getBoolean(PreferenceKeys.DEARROW_THUMBNAILS, true)) thumb else null
        return finalTitle to finalThumb
    }
}
